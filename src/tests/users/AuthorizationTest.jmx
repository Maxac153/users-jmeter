<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan">
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
    </TestPlan>
    <hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="_________CONFIG_________" enabled="false"/>
      <hashTree/>
      <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager">
        <collectionProp name="HeaderManager.headers">
          <elementProp name="Referer" elementType="Header">
            <stringProp name="Header.name">Referer</stringProp>
            <stringProp name="Header.value">http://users.bugred.ru/user/profile/index.html</stringProp>
          </elementProp>
          <elementProp name="Accept-Language" elementType="Header">
            <stringProp name="Header.name">Accept-Language</stringProp>
            <stringProp name="Header.value">ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3</stringProp>
          </elementProp>
          <elementProp name="Upgrade-Insecure-Requests" elementType="Header">
            <stringProp name="Header.name">Upgrade-Insecure-Requests</stringProp>
            <stringProp name="Header.value">1</stringProp>
          </elementProp>
          <elementProp name="Accept-Encoding" elementType="Header">
            <stringProp name="Header.name">Accept-Encoding</stringProp>
            <stringProp name="Header.value">gzip, deflate</stringProp>
          </elementProp>
          <elementProp name="User-Agent" elementType="Header">
            <stringProp name="Header.name">User-Agent</stringProp>
            <stringProp name="Header.value">Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0</stringProp>
          </elementProp>
          <elementProp name="Accept" elementType="Header">
            <stringProp name="Header.name">Accept</stringProp>
            <stringProp name="Header.value">text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</stringProp>
          </elementProp>
        </collectionProp>
      </HeaderManager>
      <hashTree/>
      <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP Cookie Manager" enabled="false">
        <collectionProp name="CookieManager.cookies"/>
        <boolProp name="CookieManager.clearEachIteration">true</boolProp>
        <boolProp name="CookieManager.controlledByThreadGroup">false</boolProp>
      </CookieManager>
      <hashTree/>
      <CacheManager guiclass="CacheManagerGui" testclass="CacheManager" testname="HTTP Cache Manager">
        <boolProp name="clearEachIteration">true</boolProp>
        <boolProp name="useExpires">true</boolProp>
        <boolProp name="CacheManager.controlledByThread">false</boolProp>
      </CacheManager>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="APP_PROTOCOL" elementType="Argument">
            <stringProp name="Argument.name">APP_PROTOCOL</stringProp>
            <stringProp name="Argument.value">${__P(APP_PROTOCOL,http)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="APP_HOST" elementType="Argument">
            <stringProp name="Argument.name">APP_HOST</stringProp>
            <stringProp name="Argument.value">${__P(APP_HOST,users.bugred.ru)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="APP_PORT" elementType="Argument">
            <stringProp name="Argument.name">APP_PORT</stringProp>
            <stringProp name="Argument.value">${__P(APP_PORT,80)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ENCODING" elementType="Argument">
            <stringProp name="Argument.name">ENCODING</stringProp>
            <stringProp name="Argument.value">${__P(ENCODING,UTF-8)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults">
        <stringProp name="HTTPSampler.domain">${APP_HOST}</stringProp>
        <stringProp name="HTTPSampler.port">${APP_PORT}</stringProp>
        <stringProp name="HTTPSampler.protocol">${APP_PROTOCOL}</stringProp>
        <stringProp name="HTTPSampler.contentEncoding">${ENCODING}</stringProp>
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
          <collectionProp name="Arguments.arguments"/>
        </elementProp>
        <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
      </ConfigTestElement>
      <hashTree/>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="_________TESTS__________" enabled="false"/>
      <hashTree/>
      <SetupThreadGroup guiclass="SetupThreadGroupGui" testclass="SetupThreadGroup" testname="setUp Thread Group">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </SetupThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Profile Info BAD!" enabled="false">
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="script">log.info(&quot;Profile Log&quot;)

/*
Profile File:
threadGroup (имя скрипта), TransactionPerHour (операций в час для 100% профиля), MinPacing (время выполениня операции не более ...), LG_Count (для не распределённых тестов = 1)
uc_01_first_group,72000,40,3
uc_02_second_group,36000,20,3
*/

def names = []
def iterations = []
def minPacing = []
def loadGeneratorsNumber = []

def step_start = []
def step_finish = []

steps = vars.get(&quot;steps&quot;) as Integer
stepsAdd = steps + 1
k = 0

String profile = vars.get(&quot;profile&quot;)
String file = new File(profile).eachLine() { line, lineNum -&gt;
	if (lineNum == 1) {
		return
	}

	log.info(&quot;Line: &quot; + line.toString())
	var0 = &apos;&apos;
	i = 0

	while(line[i] != &apos;,&apos;) {
		var0 += line[i]
		i++
	}
	i++

	names[k] = var0
	var0 = &apos;&apos;
	while(line[i] != &apos;,&apos;) {
		var0 += line[i]
		i++
	}
	i++

	iterations[k] = var0.toInteger()
	var0 = &apos;&apos;
	while(line[i] != &apos;,&apos;) {
		var0 += line[i]
		i++
	}
	i++

	minPacing[k] = var0 as Double
	var0 = &apos;&apos;
	while(i != line.size()) {
		var0 += line[i]
		i++
	}

	loadGeneratorsNumber[k] = var0 as Integer
	log.info(&quot;Lgnumbers: &quot; + loadGeneratorsNumber[k])
	k++
}

props.put(&quot;baseline_ramp&quot;, &quot;0&quot;)
props.put(&quot;baseline_duration&quot;, &quot;0&quot;)
props.put(&quot;step_rumup&quot;, &quot;0&quot;)
props.put(&quot;step_duration&quot;, &quot;0&quot;)
props.put(&quot;lg_slow&quot;, &quot;0&quot;)
props.put(&quot;test_length&quot;, &quot;0&quot;)
props.put(&quot;step_start0&quot;, &quot;0&quot;)
props.put(&quot;step_finish0&quot;, &quot;0&quot;)
props.put(&quot;step1_duration_in_min&quot;, &quot;0&quot;)
props.put(&quot;step2-7_duration_in_min&quot;, &quot;0&quot;)
props.put(&quot;currentStepNumber&quot;, &quot;0&quot;)

for (i = 0; i&lt; names.size(); i++) {
	var1 = names[i] + &quot;_start&quot;
	props.put(var1, &quot;0&quot;)

	var2 = names[i] + &quot;_add_thread&quot;
	props.put(var2, &quot;0&quot;)

	var3 = names[i] + &quot;_throughtput&quot;
	props.put(var3, &quot;0&quot;)

	var4 = names[i] + &quot;_load_generators&quot;
	props.put(var4, &quot;0&quot;)

	props.put(names[i] + &quot;_baseline&quot;, &quot;0&quot;)
}

for (i = 0; i &lt;= steps; i++) {
	z = steps - i + 1
	var4 = z + &quot;_length&quot;
	props.put(var4, &quot;0&quot;)

	var5 = i + &quot;_init_delay&quot;
	props.put(var5, &quot;0&quot;)

	if (i != steps) {
		props.put(&quot;step_start&quot; + i, &quot;0&quot;)
		props.put(&quot;step_finish&quot; + i, &quot;0&quot;)
	}
}

baseline_rampup = vars.get(&quot;baseline_rampup&quot;) as Integer
baseline_percent = (vars.get(&quot;basleline_percent&quot;) as Double) / 100
baseline_duration = vars.get(&quot;baseline_duration&quot;) as Integer

if (vars.get(&quot;step_rampup&quot;) == &quot;&quot;) {
	vars.put(&quot;step_rampup&quot;, &quot;0&quot;)
}

if (vars.get(&quot;step_percent&quot;) == &quot;&quot;) {
	vars.put(&quot;step_percent&quot;, &quot;0&quot;)
}

if (vars.get(&quot;step_duration&quot;) == &quot;&quot;) {
	vars.put(&quot;step_duration&quot;, &quot;0&quot;)
}

step_rampup = vars.get(&quot;step_rampup&quot;) as Integer
step_percent = (vars.get(&quot;step_percent&quot;) as Double) / 100
step_duration = vars.get(&quot;step_duration&quot;) as Integer
lg_slow = vars.get(&quot;lg_slow&quot;)

props.put(&quot;baseline_rampup&quot;, baseline_rampup.toString())
props.put(&quot;baseline_duration&quot;, basline_duration.toString())
props.put(&quot;step_rampup&quot;, step_rampup.toString())
props.put(&quot;step_duration&quot; step_duration.toString())
props.put(&quot;lg_slow&quot;, lg_slow.toString())

for(i = 0; i &lt; names.size(); i++) {
	if (step_percent == 0) {
		minStepLoad = iterations[i] * baseline_percent / loadGeneratorsNumber[i]
	} else {
		minStepLoad = iterations[i] * step_percent / loadGeneratorNumber[i]
	}

	oneUserLoadGeneration = 3600 / minPacing[i]
	minStepVUNumber = (Math.ceil(minStepLoad / oneUserLoadGeneration)) as Integer
	oneVUOperationsNumber = minStepLoads / minStepVUNumber
	oneVUOperationsPerMinNumber = oneVUOperationsNumber / 60

	if (step_percent == 0) {
		baseLineVUNumber = minStepVUNumer as Integer
	} else {
		baseLineVUNumber = (minStepVUNumber * (baseline_percent / step_percent)) as Integer
	}

	var1 = names[i] + &quot;_start&quot;
	props.put(var1, baseLineVUNumber as String)

	var2 = names[i] + &quot;_add_thread&quot;
	props.put(var2, minStepVUNumber as String)

	var3 = names[i] + &quot;_throughtput&quot;
	props.put(var3, oneVUOperationsPerMinNumber as String)

	var4 = names[i] + &quot;_load_generators&quot;
	props.put(names[i] + &quot;_baseline&quot;, iterations[i] as String)
}

all_length = baseline_duration + (step_rampup + step_duration) * (steps - 1)
props.put(&quot;test_lenght&quot;, (all_length * 1000) as String);

for (i = 1; i &lt;= steps; i++) {
	z = steps - i + 1
	var4 = z + &quot;_length&quot;

	if (i == steps) {
		l = all_length
	} else {
		l = all_length - (step_rampup + step_duration) * (steps - i - 1) - step_rampup - basleline_duration
	}

	var5 = i + &quot;_init_delay&quot;
	if (i == 1) {
		ind = 0
	} else if (i == 2) {
		ind = baseline_rampup + baseline_duration
	} else {
		n = i - 1
		m = n + &quot;_init_delay&quot;
		k = props.get(m) as Integer
		ind = k + step_duration + step_rampup
	}

	props.put(var5, ind as String)
}

startTestTime = props.get(&quot;TESTSTART.MS&quot;) as Long
step_start[0] = baseline_rampup
step_finish[0] = baseline_rampup + baseline_duration

props.put(&quot;step_start0&quot;, (new Date(step_start[0] * 1000 + startTestTime).format(&quot;yyyy-MM-dd HH:mm:ss&quot;)))
props.put(&quot;step_finish0&quot;, (new Date(step_finish[0] * 1000 + startTestTime).format(&quot;yyyy-MM-dd HH:mm:ss&quot;)))

props.put(&quot;step1_duration_in_min&quot;, new Date(baseline_duration * 1000 - (3 * 3_600_000)).format(&quot;HH:mm:ss&quot;)))
props.put(&quot;step2-7_duration_in_min&quot;, new Date(step_duration * 1000 - (3 * 3_600_000)).format(&quot;HH:mm:ss&quot;)))

for (i = 1; i &lt; steps; i++) {
	step_start[i] = step_finish[i - 1] + step_rampup
	step_finish[i] = step_start[i] + step_duration
	props.put(&quot;step_start&quot; + i, (new Date(step_start[i] * 1000 + startTestTime).format(&quot;yyyy-MM-dd HH:mm:ss&quot;)))
	props.put(&quot;step_finish&quot; + i, (new Date(step_finish[i] * 1000 + startTestTime).format(&quot;yyyy-MM-dd HH:mm:ss&quot;)))
}

currentTime = System.currentTimeMillis()
a = (startTestTime - currentTime) / 1000

for (i = 1; i &lt; stepsAdd; i++) {
	start = props.get(i + &quot;_init_delay&quot;) as Integer
	if (i == steps) {
		props.put(&quot;currentStepNumber&quot;, i as Integer)
		break
	}

	k = i + 1
	finish = props.get(k + &quot;_init_delay&quot;) as Integer
	if (a &gt;= start &amp;&amp; a &lt;= finish) {
		props.put(&quot;currentStepNumber&quot;, i as Integer)
		break
	}
}
</stringProp>
          <stringProp name="scriptLanguage">groovy</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Calc Profile BAD!" enabled="false">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import groovy.json.JsonSlurper


def getStepPace(double tps, double pacing) {
	double pace = 1 / tps
	
	if (tps &gt; 0 &amp;&amp; pace &gt; pacing) {
		return Math.floor(pace)
	} else if (tps &gt; 0 &amp;&amp; 1 - pace / pacing &lt; 0.96) {
		return Math.floor(pace * Math.ceil(pacing / pace) * 3)
	}
	
	return Math.floor(pacing)
}

def profilePath = System.getProperty(&quot;PROFILE_PATH&quot;, &quot;users-jmeter/src/resources/profiles/users/profile_test.json&quot;)

def profileJsonFile = new File(profilePath)
def jsonObject = new JsonSlurper().parse(profileJsonFile)
def debugEnable = jsonObject[&quot;PROPERTIES&quot;][&quot;DEBUG_ENABLE&quot;]
def precentProfile = jsonObject[&quot;PROPERTIES&quot;][&quot;PERCENT_PROFILE&quot;]
def profileName = jsonObject[&quot;PROPERTIES&quot;][&quot;PROFILE_NAME&quot;]
 
log.info(&quot;+------------------------------------------- PROFILE PARAMETERS ------------------------------------------+&quot;)
log.info(&quot;| SYSTEM PROPERTIES:&quot;)
jsonObject[&quot;PROPERTIES&quot;].each { key, value -&gt;
	log.info(&quot;|  ${key}: ${value}&quot;)
	props.put(key, value)
}

if (!debugEnable) {
	log.info(&quot;+------------------------------------------------ PROFILE ------------------------------------------------+&quot;)
	jsonObject[&quot;TESTS&quot;].each { testName, testParameters -&gt;
		def duration = 0L
	
		def maxTps = testParameters[&quot;PROFILE&quot;][&quot;STEPS&quot;].min { it.TPS }[&quot;TPS&quot;] / precentProfile * 100.0
		def pacing = getStepPace(maxTps, testParameters[&quot;PROFILE&quot;][&quot;PACING&quot;] as double)
	
		testParameters[&quot;PROFILE&quot;][&quot;STEPS&quot;].eachWithIndex { profile, index -&gt;
			def threads = (int) Math.round(profile[&quot;TPS&quot;] / precentProfile * 100.0 * pacing)
			def rampTime = (long) Math.round(profile[&quot;RAMP_TIME&quot;] * 60)
			def holdTime = (long) Math.round(profile[&quot;HOLD_TIME&quot;] * 60)
			log.info(threads as String)
			props.put(&quot;${testName}_START_THREADS_COUNT_${index}&quot;, threads)
			props.put(&quot;${testName}_INITIAL_DELAY_SEC_${index}&quot;, duration)
			props.put(&quot;${testName}_STARTUP_TIME_SEC_${index}&quot;, rampTime)
			props.put(&quot;${testName}_HOLD_LOAD_FOR_SEC_${index}&quot;, holdTime)
			props.put(&quot;${testName}_SHUTDOWN_TIME_SEC_${index}&quot;, rampTime)
			
			duration += rampTime + holdTime
		}
		props.put(&quot;${testName}_PACING&quot;, pacing)
	}
} else {
	log.info(&quot;+---------------------------------------------- DEBUG PROFILE ---------------------------------------------+&quot;)
	def profileDebugPath = System.getProperty(&quot;PROFILE_DEBUG_PATH&quot;, &quot;users-jmeter/src/resources/profiles/users/debug_test.json&quot;)
	def profileDebugJsonFile = new File(profileDebugPath)
	def jsonDebugObject = new JsonSlurper().parse(profileDebugJsonFile)
	jsonDebugObject[&quot;TESTS&quot;].each { testName -&gt;
		props.put(&quot;${testName}_PACING&quot;, 1.0)
		props.put(testName, &quot;spawn(1,0s,0s,60s,0s)&quot;)
		log.info(&quot;|  Test Name: ${testName} | Pacing: 1.0 | Profile: spawn(1,0s,0s,60s,0s)&quot;)
	}
}
log.info(&quot;+----------------------------------------------------------------------------------------------------------+&quot;)

props.put(&quot;PROFILE_NAME&quot;, profileName)</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Kafka Producer - Test1" enabled="false">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import org.apache.kafka.clients.producer.KafkaProducer

import java.util.Properties


def kafkaProperties = new Properties()

kafkaProperties.put(&quot;bootstrap.servers&quot;, &quot;&quot;)
kafkaProperties.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerialized&quot;)
kafkaProperties.put(&quot;value.serialized&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;)
kafkaProperties.put(&quot;batch.size&quot;, &quot;491520&quot;)
kafkaProperties.put(&quot;security.protocol&quot;, &quot;SSL&quot;)
kafkaProperties.put(&quot;sasl.kerberos.service.name&quot;, &quot;kafka&quot;)
kafkaProperties.put(&quot;sasl.mechanism&quot;, &quot;GSSAPI&quot;)
kafkaProperties.put(&quot;ssl.key.password&quot;, &quot;123&quot;)
kafkaProperties.put(&quot;ssl.keystore.location&quot;, &quot;src/...&quot;)
kafkaProperties.put(&quot;ssl.keystore.type&quot;, &quot;PKCS12&quot;)
kafkaProperties.put(&quot;ssl.truststore.location&quot;, &quot;src/...&quot;)
kafkaProperties.put(&quot;ssl.trustore.password&quot;, &quot;123&quot;)
kafkaProperties.put(&quot;ssl.trustore.type&quot;, &quot;PKCS12&quot;)

def producerTest = new KafkaProducer&lt;String, String&gt;(kafkaProperties)
props.put(&quot;PRODUCRE_TEST&quot;, producerTest)</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Clear Properties" enabled="false">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">props.clear()
log.info(&quot;JMeter Clear Props And Vars&quot;)</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Calc Profile">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import groovy.json.JsonSlurper


// TODO Добавить функцию расчёта TPS для низко интенсивных сценариев
def profilePath    = System.getProperty(&quot;PROFILE_PATH&quot;, &quot;users-jmeter/src/resources/profiles/users/profile_test.json&quot;)
def jsonObject     = new JsonSlurper().parse(new File(profilePath))
def debugEnable    = System.getProperty(&quot;DEBUG_ENABLE&quot;, jsonObject[&quot;PROPERTIES&quot;][&quot;DEBUG_ENABLE&quot;])
def precentProfile = jsonObject[&quot;PROPERTIES&quot;][&quot;PERCENT_PROFILE&quot;]
def profileName    = jsonObject[&quot;PROPERTIES&quot;][&quot;PROFILE_NAME&quot;]

log.info(&quot;+------------------------------------------- PROFILE PARAMETERS ------------------------------------------+&quot;)
log.info(&quot;| JMETER VARIABLES:&quot;)
vars.entrySet().each { entry -&gt;
	log.info(&quot;|  ${entry.key}: ${entry.value}&quot;)
}

log.info(&quot;| PROFILE PROPERTIES:&quot;)
jsonObject[&quot;PROPERTIES&quot;].each { key, value -&gt;
	log.info(&quot;|  ${key}: ${value}&quot;)
	props.put(key, value)
}

if (debugEnable == &quot;false&quot;) {
	log.info(&quot;+------------------------------------------------ PROFILE ------------------------------------------------+&quot;)
	jsonObject[&quot;TESTS&quot;].each { testName, testParameters -&gt;
		def duration = 0L
		def sb = new StringBuilder()
		
		def pacing = testParameters[&quot;PROFILE&quot;][&quot;PACING&quot;]
		def maxTps = testParameters[&quot;PROFILE&quot;][&quot;STEPS&quot;].min { it.TPS }[&quot;TPS&quot;] / precentProfile * 100.0
	
		testParameters[&quot;PROFILE&quot;][&quot;STEPS&quot;].each { profile -&gt;
			def threads  = (int)  Math.round(profile[&quot;TPS&quot;] * pacing / precentProfile * 100.0)
			def rampTime = (long) Math.round(profile[&quot;RAMP_TIME&quot;] * 60)
			def holdTime = (long) Math.round(profile[&quot;HOLD_TIME&quot;] * 60)
			
			sb &lt;&lt; &quot;spawn(${threads},${duration}s,${rampTime}s,${holdTime}s,${rampTime}s) &quot;
			duration += rampTime + holdTime
		}
		sb.deleteCharAt(sb.length() - 1)
	
		def profile = sb as String
		def throughput = maxTps * 60 / (int) Math.round(maxTps * pacing / precentProfile * 100.0)
		props.put(testName + &quot;_THROUGHPUT&quot;, throughput as String)
		props.put(testName, profile)
		log.info(&quot;|  Test Name: ${testName} | Pacing: ${pacing} | Throughput: ${throughput} | Profile: ${profile}&quot;)
	}
} else {
	log.info(&quot;+---------------------------------------------- DEBUG PROFILE ---------------------------------------------+&quot;)
	jsonObject[&quot;TESTS&quot;].each { testName, testParameters -&gt;
		props.put(testName, &quot;spawn(1,0s,0s,60s,0s)&quot;)
		log.info(&quot;|  Test Name: ${testName} | Pacing: 1.0 | Profile: spawn(1,0s,0s,60s,0s)&quot;)
	}
}
log.info(&quot;+---------------------------------------------------------------------------------------------------------+&quot;)</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Duration Test">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters">${__time(yyyy-MM-dd_hh-mm-ss)}</stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.ZoneId
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.StandardOpenOption
import java.util.Calendar


def formatDuration(Number timeSec) {
    long seconds   = timeSec.longValue()
    long days      = seconds / 86_400
    long remainder = seconds % 86_400
    long hours     = remainder / 3_600
    remainder      %= 3_600
    long min       = remainder / 60
    long sec       = remainder % 60
    return String.format(&quot;%02d d. %02d h. %02d m. %02d s.&quot;, days, hours, min, sec)
}

def createLogsDir() {
    Path logsDir = Paths.get(&quot;./logs/${args[0]}&quot;)
    Files.createDirectories(logsDir)
}

def calculateProfileDuration(profileData) {
    return profileData.STEPS.collect { step -&gt;
        ((step[&quot;RAMP_TIME&quot;] as int) + (step[&quot;HOLD_TIME&quot;] as int)) * 60
    }.sum() as long
}

def buildProfileInfo(profileData, calendarStartRampUp, calendarEnd) {
    def stepLogs = []
    def stepIntervals = [:]
    def stepStart = calendarStartRampUp.clone()
        
    profileData.STEPS.eachWithIndex { step, i -&gt;
        stepStart.add(Calendar.SECOND, (step[&quot;RAMP_TIME&quot;] as int) * 60)
        def stepEnd = stepStart.clone()
        stepEnd.add(Calendar.SECOND, (step[&quot;HOLD_TIME&quot;] as int) * 60)
        def stepKey = &quot;step_${i + 1}&quot;
        stepIntervals[stepKey] = &quot;from=${stepStart.time.time}&amp;to=${stepEnd.time.time}&quot;
        stepLogs &lt;&lt; String.format(&quot;Step #%-3.3s            from=%d&amp;to=%d (TPS: %s)&quot;, i + 1, stepStart.time.time, stepEnd.time.time, step[&quot;TPS&quot;])
        stepStart = stepEnd
    }
    
    def moscowZone = ZoneId.of(&quot;Europe/Moscow&quot;)
    def formatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss dd-MM-yyyy&quot;).withZone(moscowZone)
    def startZdt = calendarStartRampUp.toInstant().atZone(moscowZone)
    def endZdt = calendarEnd.toInstant().atZone(moscowZone)
    def rampUpEndTime = startZdt.plusSeconds((profileData.STEPS[0][&quot;RAMP_TIME&quot;] as int) * 60).toInstant().toEpochMilli()
    
    return [
        startTime: formatter.format(startZdt),
        endTime: formatter.format(endZdt),
        totalDuration: formatDuration((calendarEnd.time.time - calendarStartRampUp.time.time) / 1000L),
        grafanaFull: &quot;from=${calendarStartRampUp.time.time}&amp;to=${calendarEnd.time.time}&quot;,
        grafanaRampUp: &quot;from=${rampUpEndTime}&amp;to=${endZdt.toInstant().toEpochMilli()}&quot;,
        pacing: profileData[&quot;PACING&quot;] ?: &quot;N/A&quot;,
        steps: stepLogs,
        stepIntervals: stepIntervals
    ]
}

def logProfileInfo(scenarioName, profileInfo, logFileName, dateTimeNow, isLongest = false) {
    def LINE_SEPARATOR = &quot;+---------------------------------------------------------------------------------------------------------+&quot;
    
    def logLines = []
    if (isLongest) {
        logLines += [&quot;|                                             Longest Scenario&quot;, LINE_SEPARATOR]
    }
    
    logLines += [
        String.format(&quot;|  Scenario Name:       %-80.80s&quot;, scenarioName),
        LINE_SEPARATOR,
        String.format(&quot;|  Start Time:          %-80.80s&quot;, profileInfo.startTime),
        LINE_SEPARATOR,
        String.format(&quot;|  Scenario End Time:   %-80.80s&quot;, profileInfo.endTime),
        LINE_SEPARATOR,
        String.format(&quot;|  Total Duration:      %-80.80s&quot;, profileInfo.totalDuration),
        LINE_SEPARATOR,
        String.format(&quot;|  Grafana (Full):      %-80.80s&quot;, profileInfo.grafanaFull),
        LINE_SEPARATOR,
        String.format(&quot;|  Grafana (RampUp):    %-80.80s&quot;, profileInfo.grafanaRampUp),
        LINE_SEPARATOR,
        String.format(&quot;|  Pacing:              %-80.80s&quot;, profileInfo.pacing),
        LINE_SEPARATOR
    ]
    
    logLines.addAll(profileInfo.steps.collect { String.format(&quot;|  %-80.80s&quot;, it) })
    logLines &lt;&lt; LINE_SEPARATOR
    logLines.each { log.info(it) }
    
    createLogsDir()
    def logPath = Paths.get(&quot;./logs/${args[0]}/${logFileName}_profile.log&quot;)
    Files.write(logPath, logLines.collect { it }, StandardOpenOption.CREATE, StandardOpenOption.APPEND)
    
    return profileInfo
}

def saveProfileJson(scenarioName, profileInfo, logFileName, dateTimeNow) {
    createLogsDir()
    def jsonPath = Paths.get(&quot;./logs/${args[0]}/${logFileName}_profile.json&quot;)
    
    def jsonData = [
        &quot;grafana_full&quot;: profileInfo.grafanaFull,
        &quot;grafana_ramp_up&quot;: profileInfo.grafanaRampUp,
        &quot;steps&quot;: profileInfo.stepIntervals
    ]
    
    def jsonBuilder = new JsonBuilder(jsonData)
    Files.write(jsonPath, jsonBuilder.toPrettyString().bytes, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)
}

def processProfiles() {
    def profilePath = System.getProperty(&quot;PROFILE_PATH&quot;, &quot;users-jmeter/src/resources/profiles/users/profile_test.json&quot;)
    def jsonObject = new JsonSlurper().parse(new File(profilePath))
    def debugEnable = System.getProperty(&quot;DEBUG_ENABLE&quot;, jsonObject[&quot;PROPERTIES&quot;][&quot;DEBUG_ENABLE&quot;])
    
    if (debugEnable == &quot;false&quot;) {
        def logFileName = jsonObject[&quot;PROPERTIES&quot;][&quot;PROFILE_NAME&quot;] ?: &quot;profile&quot;
        def dateTimeNow = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd_HH-mm-ss&quot;))
        
        def longestDuration = 0L
        def longestScenario = null
        
        jsonObject[&quot;TESTS&quot;].each { testName, testParameters -&gt;
            def profileData = testParameters[&quot;PROFILE&quot;]
            if (profileData?.STEPS) {
                def duration = calculateProfileDuration(profileData)
                if (duration &gt; longestDuration) {
                    longestDuration = duration
                    longestScenario = [name: testName, data: profileData]
                }
            }
        }
        
        if (longestScenario) {
            def calendarStartRampUp = Calendar.getInstance()
            def calendarEnd = calendarStartRampUp.clone()
            calendarEnd.add(Calendar.SECOND, (int) longestDuration)
            
            def profileInfo = logProfileInfo(longestScenario.name, buildProfileInfo(longestScenario.data, calendarStartRampUp, calendarEnd), logFileName, dateTimeNow, true)
            saveProfileJson(longestScenario.name, profileInfo, logFileName, dateTimeNow)
        }
        
        jsonObject[&quot;TESTS&quot;].each { testName, testParameters -&gt;
            def profileData = testParameters[&quot;PROFILE&quot;]
            if (profileData?.STEPS &amp;&amp; testName != longestScenario?.name) {
                def calendarStartRampUp = Calendar.getInstance()
                def calendarEnd = calendarStartRampUp.clone()
                def duration = calculateProfileDuration(profileData)
                
                calendarEnd.add(Calendar.SECOND, (int) duration)
                logProfileInfo(testName, buildProfileInfo(profileData, calendarStartRampUp, calendarEnd), logFileName, dateTimeNow, false)
            }
        }
    }
}
processProfiles()</stringProp>
        </JSR223Sampler>
        <hashTree/>
        <DebugSampler guiclass="TestBeanGUI" testclass="DebugSampler" testname="DS - Profile">
          <boolProp name="displayJMeterProperties">true</boolProp>
          <boolProp name="displayJMeterVariables">true</boolProp>
          <boolProp name="displaySystemProperties">false</boolProp>
        </DebugSampler>
        <hashTree/>
      </hashTree>
      <PostThreadGroup guiclass="PostThreadGroupGui" testclass="PostThreadGroup" testname="tearDown Thread Group" enabled="false">
        <intProp name="ThreadGroup.num_threads">1</intProp>
        <intProp name="ThreadGroup.ramp_time">1</intProp>
        <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <stringProp name="LoopController.loops">1</stringProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
      </PostThreadGroup>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler - Kafka Close Producer" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import org.apache.kafka.clients.producer.KafkaProducer


def prodcuerTest = props.get(&quot;PRODUCER_TEST&quot;) as KafkaProducer
producerTest.close()</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <kg.apc.jmeter.threads.UltimateThreadGroup guiclass="kg.apc.jmeter.threads.UltimateThreadGroupGui" testclass="kg.apc.jmeter.threads.UltimateThreadGroup" testname="jp@gc - Ultimate Thread Group">
        <collectionProp name="ultimatethreadgroupdata">
          <collectionProp name="1480388153">
            <stringProp name="1567">10</stringProp>
            <stringProp name="48">0</stringProp>
            <stringProp name="1722">60</stringProp>
            <stringProp name="48873">180</stringProp>
            <stringProp name="1722">60</stringProp>
          </collectionProp>
          <collectionProp name="-1306469350">
            <stringProp name="1598">20</stringProp>
            <stringProp name="49710">240</stringProp>
            <stringProp name="1722">60</stringProp>
            <stringProp name="48873">180</stringProp>
            <stringProp name="1722">60</stringProp>
          </collectionProp>
        </collectionProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <intProp name="LoopController.loops">-1</intProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <stringProp name="UltimateThreadGroup.profile"></stringProp>
        <stringProp name="profile">spawn(15,1s,1s,1s,1s) spawn(40,1s,3s,1s,2s)</stringProp>
        <stringProp name="THREADS_PROFILE">${__P(T1_AUTHORIZATION)}</stringProp>
      </kg.apc.jmeter.threads.UltimateThreadGroup>
      <hashTree>
        <TestAction guiclass="TestActionGui" testclass="TestAction" testname="Flow Control Action">
          <intProp name="ActionProcessor.action">1</intProp>
          <intProp name="ActionProcessor.target">0</intProp>
          <stringProp name="ActionProcessor.duration">0</stringProp>
        </TestAction>
        <hashTree>
          <ConstantThroughputTimer guiclass="TestBeanGUI" testclass="ConstantThroughputTimer" testname="Constant Throughput Timer">
            <intProp name="calcMode">0</intProp>
            <stringProp name="throughput">${__P(T1_AUTHORIZATION_THROUGHPUT,1.0)}</stringProp>
          </ConstantThroughputTimer>
          <hashTree/>
        </hashTree>
        <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="MC Authorization Admin">
          <collectionProp name="ModuleController.node_path">
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="-264050968">TF#1 Authorization Admin</stringProp>
          </collectionProp>
        </ModuleController>
        <hashTree/>
      </hashTree>
      <kg.apc.jmeter.threads.UltimateThreadGroup guiclass="kg.apc.jmeter.threads.UltimateThreadGroupGui" testclass="kg.apc.jmeter.threads.UltimateThreadGroup" testname="jp@gc - Ultimate Thread Group">
        <collectionProp name="ultimatethreadgroupdata">
          <collectionProp name="79406796">
            <stringProp name="50">2</stringProp>
            <stringProp name="48">0</stringProp>
            <stringProp name="1722">60</stringProp>
            <stringProp name="48873">180</stringProp>
            <stringProp name="1722">60</stringProp>
          </collectionProp>
          <collectionProp name="1564428564">
            <stringProp name="56">8</stringProp>
            <stringProp name="49710">240</stringProp>
            <stringProp name="1722">60</stringProp>
            <stringProp name="48873">180</stringProp>
            <stringProp name="1722">60</stringProp>
          </collectionProp>
        </collectionProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller">
          <intProp name="LoopController.loops">-1</intProp>
          <boolProp name="LoopController.continue_forever">false</boolProp>
        </elementProp>
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <stringProp name="UltimateThreadGroup.profile"></stringProp>
        <stringProp name="profile">spawn(15,1s,1s,1s,1s) spawn(40,1s,3s,1s,2s)</stringProp>
        <stringProp name="THREADS_PROFILE">${__P(T2_AUTHORIZATION)}</stringProp>
      </kg.apc.jmeter.threads.UltimateThreadGroup>
      <hashTree>
        <TestAction guiclass="TestActionGui" testclass="TestAction" testname="Flow Control Action">
          <intProp name="ActionProcessor.action">1</intProp>
          <intProp name="ActionProcessor.target">0</intProp>
          <stringProp name="ActionProcessor.duration">0</stringProp>
        </TestAction>
        <hashTree>
          <ConstantThroughputTimer guiclass="TestBeanGUI" testclass="ConstantThroughputTimer" testname="Constant Throughput Timer">
            <intProp name="calcMode">0</intProp>
            <stringProp name="throughput">${__P(T2_AUTHORIZATION_THROUGHPUT,1.0)}</stringProp>
          </ConstantThroughputTimer>
          <hashTree/>
        </hashTree>
        <ModuleController guiclass="ModuleControllerGui" testclass="ModuleController" testname="MC Authorization Admin">
          <collectionProp name="ModuleController.node_path">
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="764597751">Test Plan</stringProp>
            <stringProp name="-52700055">TF#2 Authorization Admin</stringProp>
          </collectionProp>
        </ModuleController>
        <hashTree/>
      </hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="_______SCENARIOS_______" enabled="false"/>
      <hashTree/>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="TF#1 Authorization Admin" enabled="false"/>
      <hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="uc_users_1_rest_authorization_admin">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_1_rest_get_/main_page/ " enabled="true">
            <stringProp name="HTTPSampler.path">/</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
	&quot;data&quot;: &quot;${__RandomString(5,abcdefg)}&quot;&#xd;
}&#xd;
</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_2_rest_post_/user/login/" enabled="true">
            <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
            <stringProp name="HTTPSampler.path">/user/login/index.html</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments">
                <elementProp name="login" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.name">login</stringProp>
                  <stringProp name="Argument.value">manager@mail.ru</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
                <elementProp name="password" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.name">password</stringProp>
                  <stringProp name="Argument.value">1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_3_rest_get_/user/logout/" enabled="true">
            <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
            <stringProp name="HTTPSampler.path">/user/logout.html</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
        </hashTree>
      </hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="TF#2 Authorization Admin" enabled="false"/>
      <hashTree>
        <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="uc_users_2_rest_authorization_admin" enabled="true">
          <boolProp name="TransactionController.includeTimers">false</boolProp>
        </TransactionController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_1_rest_get_/main_page/" enabled="true">
            <stringProp name="HTTPSampler.path">/</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">{&#xd;
	&quot;data&quot;: &quot;${__RandomString(5,abcdefg)}&quot;&#xd;
}&#xd;
</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_2_rest_post_/user/login/" enabled="true">
            <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
            <stringProp name="HTTPSampler.path">/user/login/index.html</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments">
                <elementProp name="login" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.name">login</stringProp>
                  <stringProp name="Argument.value">manager@mail.ru</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
                <elementProp name="password" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.name">password</stringProp>
                  <stringProp name="Argument.value">1</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
              </collectionProp>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ur_users_3_rest_get_/user/logout/" enabled="true">
            <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
            <stringProp name="HTTPSampler.path">/user/logout.html</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <stringProp name="HTTPSampler.method">GET</stringProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables">
              <collectionProp name="Arguments.arguments"/>
            </elementProp>
          </HTTPSamplerProxy>
          <hashTree/>
        </hashTree>
      </hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="TF#2 Kafka" enabled="false"/>
      <hashTree>
        <JSR223Sampler guiclass="TestBeanGUI" testclass="JSR223Sampler" testname="JSR223 Sampler Kafka Send" enabled="true">
          <stringProp name="scriptLanguage">groovy</stringProp>
          <stringProp name="parameters"></stringProp>
          <stringProp name="filename"></stringProp>
          <stringProp name="cacheKey">true</stringProp>
          <stringProp name="script">import org.apache.kafka.clients.producer.KafkaProducer
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.header.internals.RecordHeader


def producdeerTest = props.get(&quot;PRODUCER_TEST&quot;) as KafkaProducer

def json = &quot;&quot;&quot;
{
	&quot;data&quot;: &quot;123&quot;,
	&quot;id&quot;: &quot;123&quot;
}
&quot;&quot;&quot;

def record = new ProducerRecord&lt;&gt;(&quot;topic&quot;, &quot;123&quot;, json)

record.headers().add(new RecordHeader(&quot;id&quot;, &quot;123&quot;.getBytes(&quot;UTF-8&quot;)))

producerTest.send(record)</stringProp>
        </JSR223Sampler>
        <hashTree/>
      </hashTree>
      <TestFragmentController guiclass="TestFragmentControllerGui" testclass="TestFragmentController" testname="_________DEBUG_________" enabled="false"/>
      <hashTree/>
      <BackendListener guiclass="BackendListenerGui" testclass="BackendListener" testname="Backend Listener">
        <elementProp name="arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments">
          <collectionProp name="Arguments.arguments">
            <elementProp name="influxdbMetricsSender" elementType="Argument">
              <stringProp name="Argument.name">influxdbMetricsSender</stringProp>
              <stringProp name="Argument.value">org.apache.jmeter.visualizers.backend.influxdb.HttpMetricsSender</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="influxdbUrl" elementType="Argument">
              <stringProp name="Argument.name">influxdbUrl</stringProp>
              <stringProp name="Argument.value">${__P(DATASOURCE_PROTOCOL,http)}://${__P(DATASOURCE_HOST,localhost)}:${__P(DATASOURCE_PORT,8086)}/write?db=jmeter_db</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="application" elementType="Argument">
              <stringProp name="Argument.name">application</stringProp>
              <stringProp name="Argument.value">application name</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="measurement" elementType="Argument">
              <stringProp name="Argument.name">measurement</stringProp>
              <stringProp name="Argument.value">jmeter</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="summaryOnly" elementType="Argument">
              <stringProp name="Argument.name">summaryOnly</stringProp>
              <stringProp name="Argument.value">false</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="samplersRegex" elementType="Argument">
              <stringProp name="Argument.name">samplersRegex</stringProp>
              <stringProp name="Argument.value">.*</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="percentiles" elementType="Argument">
              <stringProp name="Argument.name">percentiles</stringProp>
              <stringProp name="Argument.value">99;95;90;50</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="testTitle" elementType="Argument">
              <stringProp name="Argument.name">testTitle</stringProp>
              <stringProp name="Argument.value">Test name</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="eventTags" elementType="Argument">
              <stringProp name="Argument.name">eventTags</stringProp>
              <stringProp name="Argument.value"></stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="TAG_profile_name" elementType="Argument">
              <stringProp name="Argument.name">TAG_profile_name</stringProp>
              <stringProp name="Argument.value">${__P(PROFILE_NAME,debug)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="TAG_system_name" elementType="Argument">
              <stringProp name="Argument.name">TAG_system_name</stringProp>
              <stringProp name="Argument.value">${__P(SYSTEM_NAME,default)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
            <elementProp name="TAG_generator" elementType="Argument">
              <stringProp name="Argument.name">TAG_generator</stringProp>
              <stringProp name="Argument.value">${__P(GENERATOR,localhost)}</stringProp>
              <stringProp name="Argument.metadata">=</stringProp>
            </elementProp>
          </collectionProp>
        </elementProp>
        <stringProp name="classname">org.apache.jmeter.visualizers.backend.influxdb.InfluxdbBackendListenerClient</stringProp>
        <stringProp name="TestPlan.comments">Send metrics to InfluxDB</stringProp>
      </BackendListener>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="SimpleDataWriter" testclass="ResultCollector" testname="Simple Data Writer" enabled="false">
        <boolProp name="ResultCollector.error_logging">true</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <sentBytes>true</sentBytes>
            <url>true</url>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
            <connectTime>true</connectTime>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
